@page
@model IndexModel
@{
	ViewData["Title"] = "Philips Hue Lights";
}

<h1>Philips Hue Lights</h1>

@if (TempData["SuccessMessage"] != null)
{
	<script>
		document.addEventListener('DOMContentLoaded', function() {
			window.toaster.success('@Html.Raw(TempData["SuccessMessage"])');
		});
	</script>
}

@if (!Model.Bridges.Any())
{
	<div class="alert alert-info">
		<h5>No Hue Bridges configured</h5>
		<p>Add a Hue Bridge to start controlling your lights.</p>
		<a asp-page="AddBridge" class="btn btn-primary">Add Bridge</a>
	</div>
}
else
{
	<div class="mb-3">
		<a asp-page="AddBridge" class="btn btn-primary">Add Bridge</a>
	</div>

	@foreach (var bridge in Model.Bridges)
	{
		<div class="card mb-4">
			<div class="card-header d-flex justify-content-between align-items-center">
				<h5 class="mb-0">Bridge: @bridge.IpAddress</h5>
				<span class="badge bg-@(bridge.IsEnabled ? "success" : "secondary")">
					@(bridge.IsEnabled ? "Active" : "Inactive")
				</span>
			</div>
			<div class="card-body">
				@if (bridge.Lights.Any())
				{
					<div class="row">
						@foreach (var light in bridge.Lights.OrderBy(l => l.Name))
						{
							<div class="col-md-4 col-lg-3 mb-3">
								<div class="card h-100 light-card" data-bridge-id="@bridge.BridgeId" data-light-id="@light.Id">
									<div class="card-body">
										<h6 class="card-title">@light.Name</h6>
										<div class="mb-2">
											<div class="form-check form-switch">
												<input class="form-check-input light-switch"
												       type="checkbox"
												       data-bridge-id="@bridge.BridgeId"
												       data-light-id="@light.Id"
												       @(light.IsOn ? "checked" : "")
												       @(!light.IsReachable ? "disabled" : "")>
												<label class="form-check-label">
													<span class="light-status">@(light.IsOn ? "On" : "Off")</span>
													@if (!light.IsReachable)
													{
														<small class="text-muted">(Unreachable)</small>
													}
												</label>
											</div>
										</div>
										@if (light.Brightness.HasValue && light.IsReachable)
										{
											<div class="mb-2">
												<label class="form-label small">Brightness</label>
												<input type="range"
												       class="form-range brightness-slider"
												       min="1"
												       max="254"
												       value="@light.Brightness"
												       data-bridge-id="@bridge.BridgeId"
												       data-light-id="@light.Id">
												<small class="text-muted brightness-value">@((int)(light.Brightness.Value / 254.0 * 100))%</small>
											</div>
										}
										<small class="text-muted">@light.Type</small>
									</div>
								</div>
							</div>
						}
					</div>
				}
				else
				{
					<p>No lights found. Make sure the bridge is connected and lights are available.</p>
					<button class="btn btn-sm btn-secondary refresh-lights" data-bridge-id="@bridge.BridgeId">
						Refresh Lights
					</button>
				}
			</div>
		</div>
	}
}

@section Scripts {
	<script src="~/lib/microsoft-signalr/signalr.min.js"></script>
	<script>
		$(document).ready(function() {
			// Add CSRF token to all AJAX requests
			var token = $('input[name="__RequestVerificationToken"]').val();
			if (!token) {
				// If token not found in form, add a hidden form with token
				const tokenField = '@Html.AntiForgeryToken()';
				const match = tokenField.match(/value="([^"]+)"/);
				if (match) {
					token = match[1];
				}
			}

			// Track active brightness updates to prevent conflicts
			var activeBrightnessUpdates = {};

			// Track user-initiated changes to suppress notifications
			var userInitiatedChanges = new Map();
			const CHANGE_SUPPRESSION_DURATION = 3000; // Suppress notifications for 3 seconds after user action

			// Helper function to create a change key
			function getChangeKey(bridgeId, lightId) {
				return `${bridgeId}-${lightId}`;
			}

			// Helper function to track user-initiated change
			function trackUserChange(bridgeId, lightId, changeType, value) {
				const key = getChangeKey(bridgeId, lightId);
				const changeData = {
					type: changeType,
					value: value,
					timestamp: Date.now()
				};
				
				// Store or update the change data
				if (!userInitiatedChanges.has(key)) {
					userInitiatedChanges.set(key, []);
				}
				userInitiatedChanges.get(key).push(changeData);
				
				// Clean up old entries after suppression duration
				setTimeout(() => {
					const changes = userInitiatedChanges.get(key);
					if (changes) {
						const now = Date.now();
						const filtered = changes.filter(c => now - c.timestamp < CHANGE_SUPPRESSION_DURATION);
						if (filtered.length === 0) {
							userInitiatedChanges.delete(key);
						} else {
							userInitiatedChanges.set(key, filtered);
						}
					}
				}, CHANGE_SUPPRESSION_DURATION);
			}

			// Helper function to check if a change should be suppressed
			function shouldSuppressNotification(bridgeId, lightId, changeData) {
				const key = getChangeKey(bridgeId, lightId);
				const userChanges = userInitiatedChanges.get(key);
				
				if (!userChanges || userChanges.length === 0) {
					return false;
				}
				
				const now = Date.now();
				
				// Check if any recent user changes match this update
				return userChanges.some(userChange => {
					// Check if change is within suppression window
					if (now - userChange.timestamp > CHANGE_SUPPRESSION_DURATION) {
						return false;
					}
					
					// Check if the change type matches
					if (changeData.isOn !== undefined && userChange.type === 'power') {
						return changeData.isOn === userChange.value;
					}
					
					if (changeData.brightness !== undefined && userChange.type === 'brightness') {
						// Allow some tolerance for brightness values
						return Math.abs(changeData.brightness - userChange.value) <= 5;
					}
					
					return false;
				});
			}

			// SignalR connection
			var connection = null;

			// Initialize SignalR connection
			async function initializeSignalR() {
				connection = new signalR.HubConnectionBuilder()
					.withUrl("/lightsHub")
					.withAutomaticReconnect()
					.configureLogging(signalR.LogLevel.Information)
					.build();

				connection.on("LightStateChanged",
					function(changes) {
						console.log("Received light state changes:", changes);
						
						// Filter out changes that were initiated by the user
						let externalChanges = changes.filter(change => 
							!shouldSuppressNotification(change.bridgeId, change.lightId, change)
						);
						
						// Update UI for all changes
						changes.forEach(function(change) {
							updateLightUI(change);
						});
						
						// Only show notification for external changes
						if (externalChanges.length > 0) {
							window.toaster.info(`Updated ${externalChanges.length} light(s)`);
						}
					});

				connection.onreconnected(() => {
					window.toaster.success("Reconnected to live updates");
					connection.invoke("JoinLightsPage").catch(err => console.error("Failed to rejoin lights page:", err));
				});

				connection.onreconnecting(() => {
					window.toaster.warning("Reconnecting to live updates...", 0);
				});

				connection.onclose(() => {
					window.toaster.error("Lost connection to live updates");
				});

				try {
					await connection.start();
					await connection.invoke("JoinLightsPage");
					window.toaster.success("Connected to live updates");
				} catch (err) {
					console.error("Error connecting to lights hub:", err);
					window.toaster.error("Failed to connect to live updates");
				}
			}

			// Update light UI based on state change
			function updateLightUI(change) {
				var lightCard = $(`.light-card[data-bridge-id="${change.bridgeId}"][data-light-id="${change.lightId}"]`);
				if (lightCard.length === 0) return;

				// Update switch state
				const switchElement = lightCard.find('.light-switch');
				if (switchElement.prop('checked') !== change.isOn) {
					switchElement.prop('checked', change.isOn);
					lightCard.find('.light-status').text(change.isOn ? 'On' : 'Off');
				}

				// Update brightness
				if (change.brightness !== null && change.brightness !== undefined) {
					const slider = lightCard.find('.brightness-slider');
					if (slider.length && parseInt(slider.val()) !== change.brightness) {
						slider.val(change.brightness);
						const percentage = Math.round((change.brightness / 254) * 100);
						lightCard.find('.brightness-value').text(percentage + '%');
					}
				}

				// Update reachability
				switchElement.prop('disabled', !change.isReachable);
				if (!change.isReachable) {
					if (!lightCard.find('.text-muted:contains("Unreachable")').length) {
						switchElement.siblings('label').append('<small class="text-muted">(Unreachable)</small>');
					}
				} else {
					lightCard.find('.text-muted:contains("Unreachable")').remove();
				}

				// Add visual feedback
				lightCard.addClass('updated');
				setTimeout(() => lightCard.removeClass('updated'), 1000);
			}

			// Start SignalR connection
			initializeSignalR();

			// Handle light switch toggle
			$('.light-switch').change(function() {
				const checkbox = $(this);
				const bridgeId = checkbox.data('bridge-id');
				const lightId = checkbox.data('light-id');
				const isOn = checkbox.is(':checked');
				const brightnessSlider = checkbox.closest('.card-body').find(`.brightness-slider[data-light-id="${lightId}"]`);

				// Track this user-initiated change
				trackUserChange(bridgeId, lightId, 'power', isOn);

				// Prepare data
				const data = {
					bridgeId: bridgeId,
					lightId: lightId,
					on: isOn
				};

				// If turning on, include the current brightness value from the slider
				if (isOn && brightnessSlider.length) {
					const brightness = parseInt(brightnessSlider.val());
					data.brightness = brightness;
					// Also track the brightness change when turning on
					trackUserChange(bridgeId, lightId, 'brightness', brightness);
				}

				$.ajax({
					url: '/Lights/Index?handler=ToggleLight',
					type: 'POST',
					headers: {
						'RequestVerificationToken': token
					},
					data: data,
					success: function() {
						checkbox.siblings('label').find('.light-status').text(isOn ? 'On' : 'Off');
					},
					error: function(xhr, status, error) {
						// Revert on failure
						checkbox.prop('checked', !isOn);
						console.error('Error toggling light:', error);
						window.toaster.error(`Failed to toggle light: ${xhr.responseText || error}`);
					}
				});
			});

			// Handle brightness change - update display immediately
			$('.brightness-slider').on('input',
				function() {
					const slider = $(this);
					const brightness = parseInt(slider.val());
					const percentage = Math.round((brightness / 254) * 100);
					slider.siblings('.brightness-value').text(percentage + '%');
				});

			// Handle brightness change - send to API when user stops sliding
			$('.brightness-slider').on('change',
				function() {
					const slider = $(this);
					const bridgeId = slider.data('bridge-id');
					const lightId = slider.data('light-id');
					const brightness = parseInt(slider.val());
					const key = bridgeId + '-' + lightId;
					const checkbox = slider.closest('.card-body').find(`.light-switch[data-light-id="${lightId}"]`);
					const isLightOn = checkbox.is(':checked');

					// Track this user-initiated change
					trackUserChange(bridgeId, lightId, 'brightness', brightness);

					// Cancel any pending update for this light
					if (activeBrightnessUpdates[key]) {
						clearTimeout(activeBrightnessUpdates[key]);
					}

					// Store the current brightness value
					slider.data('last-brightness', brightness);

					// Only send brightness update to the API if the light is currently on
					if (isLightOn) {
						// Set a short delay to batch rapid changes
						activeBrightnessUpdates[key] = setTimeout(function() {
								$.ajax({
									url: '/Lights/Index?handler=SetBrightness',
									type: 'POST',
									headers: {
										'RequestVerificationToken': token
									},
									data: {
										bridgeId: bridgeId,
										lightId: lightId,
										brightness: brightness
									},
									success: function() {
										delete activeBrightnessUpdates[key];
										console.log('Brightness set to:', brightness);
									},
									error: function(xhr, status, error) {
										delete activeBrightnessUpdates[key];
										console.error('Error setting brightness:', error);

										// Try to revert to previous value if we have it
										const lastValue = slider.data('last-brightness');
										if (lastValue !== undefined && lastValue !== brightness) {
											slider.val(lastValue);
											const percentage = Math.round((lastValue / 254) * 100);
											slider.siblings('.brightness-value').text(percentage + '%');
										}

										window.toaster.error(`Failed to set brightness: ${xhr.responseText || error}`);
									}
								});
							},
							100); // Very short delay, just to batch rapid movements
					}
					// If light is off, we just store the value locally - it will be used when turning on
				});

			// Handle refresh lights
			$('.refresh-lights').click(function() {
				const button = $(this);
				const bridgeId = button.data('bridge-id');
				button.prop('disabled', true).text('Refreshing...');

				$.ajax({
					url: '/Lights/Index?handler=RefreshLights',
					type: 'POST',
					headers: {
						'RequestVerificationToken': token
					},
					data: { bridgeId: bridgeId },
					success: function() {
						location.reload();
					},
					error: function(xhr, status, error) {
						console.error('Error refreshing lights:', error);
						window.toaster.error(`Failed to refresh lights: ${xhr.responseText || error}`);
					},
					complete: function() {
						button.prop('disabled', false).text('Refresh Lights');
					}
				});
			});
		});
	</script>
}